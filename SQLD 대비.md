## 데이터 모델링

**#모델링의 다양한 정의**

- 어떤 것에 대한 예비 표현으로 그로부터 최종 대상이 구축되도록 하는 계획으로서 기여하는 것(Webster 사전)
- 사물 또는 사건에 관한 양상이나 관점을 연관된 사람이나 그룹을 위해 명확하게 하는 것
- 복잡한 현실세계를 단순화시켜서 데이터베이스를 구축하기 위한 방법(현실 세계의 추상화 된 반영)



**#데이터베이스 모델링 종류**

- 개념적 데이터모델링 : 전사적인 데이터 모델로 기업 전체 데이터베이스 구조를 모델링한다. 높은 추상화수준
- 논리적 데이터모델링 : 재상용성이 높은 데이터 모델로 시스템을 구축하기 위한 데이터베이스 모델. 키, 속성, 관계 등을 표현한다.
- 물리적 데이터모델링 : 물리적 저장장치를 고려해 저장장치에 맞게 데이터베이스를 구축한다. 데이터베이스 성능, 가용성, 보안 등을 고려한다.



**#데이터베이스 모델링 시에 고려사항**

- 파급효과 : 데이터베이스를 모델링하고 통합 테스트 완료 이후 데이터베이스 모델링이 변경되면 파급효과가 크다.
- 복잡한 요구사항을 간결하게 표현할 것
- 데이터의 품질



**#좋은 데이터 모델의 요소**

- 유연성 : 업무 변화에 따라 유연하게 변경될 수 있다.
- 독립성 : 데이터 표준화 및 정규화를 통한 데이터 독립성이 좋다.
- 재사용성 : 데이터 독립성이 높으면 재사용성이 높아진다.
- 완전성 : 업무에서 필요한 모든 데이터에 대해 모델링 되어야 한다.
- 그 외 : 중복배제, 업무규칙, 통합성



**#성능 데이터 모델링 시 고려사항**

- 정규화를 수행한다.
- 데이터베이스가 저장하거나 처리되는 트랜잭션의 용량을 산정한다.
- 애플리케이션 트랜잭션의 유형(Create, Read, Update, Delete)을 분석한다.
- 데이터 용량과 트랜잭션의 유형에 따른 반정규화를 수행한다.
- 슈퍼 타입과 서브 타입, 이력 데이터, 기본키와 외래키 등을 조정한다.



**#3층 스키마**

- 외부 스키마 : 사용자 관점. 업무상 관련이 있는 데이터만 접근한다. 관련된 데이터베이스의 일부만 표시한다.
- 개념 스키마 : 사용자 전체 집단에 데이터베이스의 구조를 표현한다. Integration과 Reuse를 중요하게 강조한다.
- 내부 스키마(물리적 스키마) : 데이터베이스의 물리적 저장구조이다. 데이터 저장구조, 레코드의 구조, 필드의 정의, 색인과 해시를 생성한다. 운영체제와 하드웨어에 종속적이다.



**#데이터베이스 품질을 저하할 수 있는 요소**

- 중복(Duplication) : 중복된 데이터는 데이터베이스의 유연성을 떨어뜨린다. 통제대상 데이터를 증가시킨다.
- 비유연성(inflexibility) : 비지니스 프로세스와 데이터를 분리해 유연성을 향상시켜야 한다.
- 비일괄성(consistency) : 관련된 데이터 간에 불일치가 발생하면 안된다.



**#엔터티의 공통점**

- 개념, 사건, 사람, 장소 등과 같이 "명사"이다.
- 비지니스 프로세스에서 "관리되어야 하는 정보"이다.
- "저장"이 필요한 어떤 것(Thing)이다.



**#관계(Relation)** : 엔터티 간의 관련성

- 통계성 엔터티와 코드성 엔터티, 시스템 내부 엔터티는 관계 생략이 가능하다.
- 존재관계(엔터티 간의 상태)와 행위관계(엔터티 간에 어떤 행위가 있는 것)로 나뉜다.



**#주식별자 도출 기준**

- 업무에서 자주 사용되는 속성인지
- 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 주의한다.
- 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않는다.
- cf) 주식별자를 식별할 수 없을 때는 일렬번호(ROWNUM)를 사용해서 주식별자를 대신할 수 있다.



**#주식별자가 가져야 하는 특징**

- 유일성, 최소성, 불변성, 존재성



**#정규화 과정과 그 특징**

- 제 1정규화 : 모든 속성의 원자성을 만족해야 한다. (함수적 종속성을 확인하고 기본키를 잡는 것)
- 제 2정규화 : 부분함수 종속성 제거 (기본키가 2개 이상의 칼럼으로 이루어진 경우에만 발생하며 모든 결정자이면서 후보키가 아닌 것 제거)
- 제 3정규화 : 이행함수 종속성 제거 (기본키를 제외한 칼럼간에 종속성이 발생하는 경우 제거)

- BCNF : 릴레이션 R이 정규화를 만족하고, 릴레이션 R의 모든 식별자가 후보키의 역할을 수행한다.



**#카디널리티(Cardinality)** : 두 개의 엔터티에서 관계에 참여하는 수

- 선택도 * 전체 레코드 수



**#반정규화의 대상**

- 자주 사용하는 테이블에 접근하는 프로세스 (범위 처리 빈도수)
- 테이블 내에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 프로세스 (대량 범위)
- 통계성 프로세스
- 테이블 내 많은 조인 연산이 발생하는 프로세스 (테이블 조인 개수)



**#칼럼에 대한 반정규화**

- 단순히 업무처리를 위한 기능칼럼 추가(예: 부양가족이 있는 사원의 사원번호 추가)는 반정규화가 아니다. 집계함수를 통해 미리 계산을 한 칼럼을 추가하거나 하는 등이 반정규화에 해당될 수 있다. (ex: 평균을 계산한 칼럼 추가, 합계 칼럼을 추가하고 배치 프로세스로 합계를 계산하여 삽입 등)



**#테이블 추가 반정규화 기법**

- 중복 테이블 추가 : 동일한 테이블을 중복해서 만드는 것으로 분산 데이터베이스에서 원격으로 조인할 때 사용한다.
- 통계 테이블 추가 : 사전에 합계, 평균 등을 계산해 조회 성능을 향상시킨다. 계좌평가 시에 평가금액을 배치로 계산해서 추가한다.
- 이력 테이블 추가 : 마스터 테이블의 데이터를 이력 테이블에 추가해 이력을 관리한다.
- 부분 테이블 추가 : 자주 이용되는 칼럼에 대해서 디스크 IO량을 감소시키기 위해서 해당 칼럼을 별도로 분리하는 방법이다.



**#반정규화를 적용하는 경우**

- 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되는 경우
- 조인으로 인한 성능저하가 예상되는 경우
- 칼럼을 계산해서 읽을 때 성능이 저하될 것으로 예상되는 경우



**#분산데이터베이스의 장점과 단점**

- 장점
  - 데이터베이스의 신뢰성과 가용성이 높다.
  - 분산 데이터베이스가 병렬 처리를 수행하기 때문에 빠른 응답이 가능하다.
  - 분산 데이터베이스를 추가해 시스템 용량 확장이 쉽다.
- 단점
  - 데이터베이스가 여러 네트워크를 통해서 분리되어 있기 때문에 관리와 통제가 어렵다.
  - 보안관리가 어렵다.
  - 데이터 무결성 관리가 어렵다.
  - 데이터베이스 설계가 복잡하다.



**#분산 데이터베이스의 투명성**

- 분할 투명성 : 하나의 논리적 릴레이션이 여러 단편으로 분할돼 각 단편의 사본이 여러 site(위치)에 저장
- 위치 투명성 : 사용하려는 데이터의 저장 장소 명시가 불필요하며 위치정보가 System Catalog에 유지돼야 한다. => 데이터의 저장장소와 관련이 없다!
- 지역사상 투명성 : 지역 DBMS와 물리적 DB사이의 Mapping을 보장해야 한다. (각 지역시스템 이름과 무관한 이름은 사용 가능)
- 중복 투명성 : DB 객체가 여러 site에 중복돼 있는지 알 필요가 없는 성질
- 장애 투명성 : 구성요소(DBMS, Computer)의 장애에 무관한 트랜잭션의 원자성 유지
- 병행 투명성 : 다수의 트랜잭션을 동시에 수행 시 결과의 일관성 유지, Time Stamp, 분산 2단계 Locking을 이용 구현





※개체 무결성 : 주식별자는 중복된 값을 가질 수 없고 Not Null이어야 한다.





-----------------

## SQL 기본 및 활용

**#문자열을 결합하는 부호 or 함수**

CONCAT(A, B) , A||B , A + B



**#트랜잭션**

- 트랜잭션은 데이터베이스에서 독립적으로 처리될 수 있는 최소 단위 연산이다.
- 트랜잭션의 수행 결과는 Commit 혹은 Rollback을 수행해야 한다.
- 트랜잭션은 가급적 빠르게 처리되어야 한다.
- 특징 : 원자성, 일관성, 고립성, 지속성
- Commit : 데이터베이스의 변경사항을 로그파일에 기록한다. Write Ahead Logging은 데이터베이스 사용자가 Commit을 하면 로그파일에 기록하고, Check point가 발생할 때 최종적으로 데이터 파일에 저장한다. 트랜잭션의 처리 속도를 높이는 방법
- Commit 이후의 데이터 상태
  - 데이터에 대한 변경 사항이 데이터베이스에 저장된다.
  - 이전 데이터는 삭제된다.
  - 다른 사용자도 결과를 볼 수 있다.
  - 다른 사용자들이 행을 조작할 수 있다.



**#대용량 배치 프로그램의 속도를 향상시키기 위한 튜닝 방안**

- 인덱스를 제거했다가 나중에 다시 생성한다.
- 수정 가능 조인 뷰(Updatable Join View)나 Merge문을 활용한다.
- SQL Server라면 최소 로깅(Minimal Logging) 모드 Insert 기능을 활용한다.
- Oracle이라면 insert문을 수행하기 전에 테이블을 nologging 모드로 변경한다. (Nologging 옵션은 INSERT문에만 효과가 있다.)



**#WHERE절**

- WHERE절에는 집계함수를 사용할 수 없다.



**#GROUP BY절**

- join을 할 경우 GROUP BY절에서 value가 어느 테이블의 칼럼인지 정확히 명시해주어야 한다.
- GROUP BY는 소그룹의 집계 기준을 정하고 SELECT절에 집계함수를 사용한다.
  - 역으로 집계함수가 나오면 GROUP BY절이 필요하다고 볼 수도 있다.
  - 집계함수에서 NULL은 자동으로 제외된다.
- SELECT절에서 사용하는 ALIAS(별칭)는 GROUP BY절에서 사용할 수 없다.



**#ORDER BY절**

- SQL Server에서 오름차순으로 정렬하면 NULL값이 가장 먼저 나온다.
- SELECT목록에 나타나지 않은 문자형 항목이 포함될 수 있다.
- 쿼리 내 SELECT절에 정의되지 않은 칼럼도 사용 가능하다.



**#Natural Join의 특징**

- Natural Join : 두 테이블 간에 동일한 칼럼 이름을 가진 것을 모두 출력하는 조인 방법
- Alias를 사용할 수 없다.
- 동일한 칼럼이 두 개 이상일 경우 JOIN~USING 문장을 사용한다.
- Natural Join에서 사용된 열은 식별자를 가질 수 없다.



**#세미조인(semi join)** : A, B가 조인될 경우 A와 조인될 가능성이 있는 B의 행(튜플)만을 골라 전송하는 연산



**#조인 조건이 없는 경우**

- 조인 조건이 없어도 SQL문은 실행된다.
- 조인 조건이 없다고 문법 오류가 발생하지는 않는다.
- 조인 조건이 없으면 Cartesian Product가 발생할 수 있다.



**#Oracle 데이터베이스 조인 방식**

- Nested Loop : 중첩 루프를 사용해서 선행 테이블(Outer Table)을 먼저 스캔하면서 후행 테이블(Internal Table)을 조인하는 방식으로 Random Access가 많이 발생한다.

  - Nested Loop방식의 조인 절차 

    1) 선행 테이블에서 조건을 만족하는 첫번째 

    2) 선행 테이블의 조인 키를 가지고 후행 테이블에 조인 키가 존재하는지 찾으러 가서 조인을 시도한다.

    3) 후행 테이블의 인덱스에 선행 테이블의 조인 키가 존재하는지 확인한다.

    4) 인덱스에서 추출한 레코드 식별자를 이용해 후행 테이블을 액세스한다.

    EX)

    1) TABLE ACCESS(FULL) => 2) INDEX(RANGE SCAN) => 3) TABLE ACCESS(BY INDEX ROWID) =>

    4) NESTED LOOP JOIN => 5) INDEX(RANGE SCAN) => 6) TABLE ACCESS(BY INDEX ROWID) =>

    7) NESTED LOOP JOIN => 8) SELECT~ 

  - 처리 범위가 좁은 것이 유리하다.

  - 결과를 가능한 빨리 화면에 보여줘야 하는 인터넷 서비스 등에 유리한 조인방식이다.

  - 선행 테이블이 조건을 만족할 때까지 반복 수행한다.

- Sort Merge : 두 개의 테이블을 Sort한 후에 Merge하면서 조인을 하는 방식으로 데이터가 많으면 Sort 시에 부하가 발생할 수 있다. 조인되는 테이블을 모두 메모리에 로드하고 병렬로 스캔하면서 정렬을 수행 후 머지하는 것!
  - 기본키와 외래키 관계에서 외래키에 인덱스가 없을 때 효율적이다.
  - 배치작업에서 많이 사용된다.
- Hash  : 해시함수를 사용해 드라이브 테이블이 조인되는 테이블에 접근해 조인을 시도한다.
  - 해시조인은 해시함수를 사용해서 주소를 계산하고 조인을 수행한다.
  - 해시조인을 할 때는 선행 테이블의 크기가 작아야 한다.
  - 해시조인은 CPU연산이 많이 발생한다.



**#계층형 쿼리**

- 중복이 생겼을 때 루프를 돌지 않기 위해 NO CYCLE 옵션을 사용할 수 있다.
- ORDER SIBLINGS BY를 사용하면 특정 칼럼 기준으로 정렬할 수 있다.



**#Subquery의 유형**

- Scala Subquery : 반드시 한 행과 한 칼럼만 반환하는 서브쿼리. 만약 여러 행이 반환되면 오류가 발생한다. Select문에서 사용하는 서브쿼리
  - From절의 subquery : 인라인 뷰
  - where절의 subquery : 서브쿼리
- Correlated(상호 연관) Subquery : Subquery 내에서 Main Query 내의 칼럼을 사용하는 것. 메인 쿼리 값을 서브쿼리가 사용하고 서브쿼리의 값을 받아서 메인쿼리가 계산되는 쿼리이다.
- Access Subquery : 쿼리의 변형이 없고 제공자의 역할을 하는 서브쿼리
- Filter Subquery : 쿼리의 변형이 없고 확인자 역할을 하는 서브쿼리
- Early Filter Subquery : 쿼리의 변형이 없고 서브쿼리가 먼저 실행해 데이터를 걸러내는 서브쿼리



**#Subquery 사용시 주의할 점**

- 서브쿼리를 괄호로 감싸서 사용한다.
- 서브쿼리는 단일행 또는 복수행 비교 연산자와 함께 사용 가능하다.
- 서브쿼리는 ORDER BY를 사용하지 못한다.
- 메인쿼리는 서브쿼리의 칼럼을 사용할 수 있다. (특히 inline view의 칼럼을!)



**#데이터베이스 관리 시간 관련 용어**

- Elapsed Time : Response Time + Idle Time
  - Response Time : CPU Time + Queue Time
    - CPU Time : Service Time
    - Queue Time : 서비스를 위한 대기시간

  - Idle Time : 사용자가 실행한 시간과 Oracle이 실행한 시간의 차이



**#파싱의 종류**

- 소프트 파싱 : SQL 파싱 정보를 저장하고 있는 라이브러리 캐시에서 파싱된 정보를 찾을 수 있는 경우 소프트 파싱이 일어난다. 소프트 파싱은 파싱 단계를 생략하고 실행단계로 넘어간다. => SQL실행의 효율성이 높아짐
- 하드 파싱 : 라이브러리 캐시에서 해당 SQL문 파싱정보를 찾을 수 없을 때 파싱을 수행하고 실행하는 과정을 하드 파싱이라고 한다.

- Database Call 과정 (SELECT 관련임!)
  - Select문을 실행하면 Parse => Execute => Fetch문으로 실행된다.
  - INSERT문과 UPDATE문장에서는 절대로 Fetch Call이 발생하지 않는다.
  - Database Call이 적을수록 성능에 유리하다.
  - 메모리에 데이터가 없을 때 물리적 IO를 실행하고 데이터가 메모리에 있으면 논리적 IO를 실행한다.



**#Dynamic SQL & Static SQL**

- 동적 SQL문은 프로그램 언어의 String 변수에 SQL문을 문자열 형태로 저장하고 실행하는 SQL문이다.
- 동적 SQL문이라고 무조건 하드 파싱되는 것은 아니다.
- 정적 SQL은 SQL코드를 직접 사용해서 실행한다.



**#View Merging이 불가능한 경우** (View Merging : 옵티마이저가 SQL 실행을 최적화하기 위해서 SQL문을 가공하는 작업)

- 집합 연산자(union, union all, minus, intersect)를 사용하는 경우
- Connect by절을 사용하는 경우
- ROWNUM을 사용하는 경우
- SELECT 구에 집계함수를 사용하는 경우
- 분석함수를 사용하는 경우



**#PL-SQL (절차형 SQL)**

- 절차형 SQL : 일반 프로그래밍 언어처럼 데이터베이스 관련 프로그램을 순서적으로 작성할 수 있는 언어
- IF, LOOP 등의 절차형 언어를 사용해 절차적인 프로그램이 가능하다.
- PL/SQL에서 조건문은 IF ~ THEN ~ ELSEIF ~ END IF와 CASE ~ WHEN을 사용한다.
- PL/SQL 내부에서 테이블을 생성할 수 있다. 내부에서 테이블을 생성하는 이유는 임시 테이블로 잠깐 이용하기 위한 용도가 많다.
- PL/SQL에서 name이라는 변수에 'aaa'를 대입할 경우 ":="을 사용한다.
- 응용 프로그램의 성능을 향상시킨다.
- 여러 SQL 문장을 BLOCK으로 묶고 한 번에 BLOCK 전부를 서버로 보내기 때문에 통신량을 줄일 수 있다.
- 절차형 SQL을 이용해 PROCEDURE, TRIGGER, USER DEFINED FUNCTION 등을 주로 만든다.
- Oracle : PL/SQL   	/		DB2 : SQL/PL  	  /		 MSSQL : T-SQL



**#인덱스 특징**

- INSERT, UPDATE, DELETE 등과 같은 DML 작업은 테이블과 인덱스를 함께 변경하기 때문에 인덱스 생성 시 느려질 수 있다.
- 테이블에 인덱스를 생성하지 않아도 되고 여러 개를 생성해도 된다.
- 테이블 기반으로 선택적으로 생성할 수 있는 구조이다.
- B-TREE 인덱스는 브랜치블록과 리프블록으로 구성된다.



**#인덱스를 사용할 수 없는 조건**   ★

- 컬럼의 변형 => select SAWON_NO, NAME from T_SAWON where substr(SAWON_NO, 1, 4)='2002'; 
- 부정형의 비교 => select SAWON_NO, NAME from T_SAWON where SAWON_NO <> '20101016';
- IS NOT NULL의 사용 (엄밀히 말하면 사용할 수 있지만 효율성이 떨어진다) => select SAWON_NO, NAME from T_SAWON where SAWON_NO is not null; 
- DATE 컬럼과 NUMBER 컬럼에 LIKE 사용 => select SAWON_NO, NAME from T_SAWON where AMT_LIKE '1000%';
- LIKE 사용시 앞에 % 사용 => select SAWON_NO, NAME from T_SAWON where SAWON_NO LIKE '%20101016';  



**#인덱스 스캔 방식**

- 인덱스 유일 스캔 (Index Unique SCAN) : 인덱스의 키 값이 중복되지 않는 경우 해당 인덱스를 사용할 때 발생
  - 유일 인덱스 스캔은 PK 또는 유니크 인덱스로 액세스 해야 한다.
- 인덱스 범위 스캔 (Index Range SCAN) : SELECT문에서 특정 범위를 조회하는 WHERE문을 사용할 경우 발생. 인덱스의 Leaf Block의 특정 범위를 스캔한 것이다.
- 인덱스 전체 스캔(Index Full SCAN) : 인덱스에서 검색되는 인덱스 키가 많은 경우에 Leaf Block의 처음부터 끝까지 전체를 읽어 들인다.
- 테이블 전체 스캔(Table Full SCAN) 
  - 테이블의 데이터를 모두 읽는 것 
  - 테이블을 읽을 때 High Water mark 이하까지만 Table Full Scan을 한다. 데이터가 삭제되면 High Water mark가 변경된다.
    - High Water mark : 테이블에 데이터가 저장된 블록에서 최상위 위치
  - 하나의 데이터(행)을 읽기 위해서는 인덱스를 사용하지 않고 TABLE FULL SCAN으로 테이블을 FULL SCAN하는 것이 효율적이다. 
- 인덱스 범위 역순 스캔(Index Range SCAN DESCENDING) : 인덱스를 역순으로 탐색하며 최대값을 쉽게 찾을 수 있다.



**#Row의 잘못된 삽입으로 인한 성능 저하**

- Row Chaining : 행(Row)의 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 행(Row)이 저장되어 있는 형태
- Row Migration : 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식
- Row Chaining과 Row Migration이 발생해서 많은 블록에 데이터가 저장되면 데이터베이스 메모리에서 디스크와의 I/O(입출력)가 불필요하게 많이 발생해 성능이 저하된다.



※NOT 조건인 경우 NULL 연산이 Unknown으로 처리돼 True로 반환될 수 있다.

※EXIST를 사용할 경우 데이터의 존재여부만 간단하게 확인해 더 효율적으로 데이터를 검색할 수 있다.

※Subquery가 멀티 행을 리턴할 경우 "="절이 아닌 IN절로 받아야 한다.

※IOT(Index Organized Table) 인덱스 : 인덱스와 테이블이 같은 저장소에 생성돼서 SQL문이 실행될 때 데이터를 빠르게 검색할 수 있다. => 테이블을 탐색하지 않고 Fetch하려고 하는 경우 IOT를 생성해야 한다. (테이블을 참조하지 않는 인덱스, 즉 인덱스의 key가 fetch하는 추출의 칼럼으로 이루어진 인덱스는 IOT를 의미한다.)

- ex) CREATE TABLE emp_test (empno VARCHAR2(20) PRIMARY KEY, ename VARCHAR2(50)) ORGANIZATION INDEX;

※BUILT-IN FUNCTION : UPPER, LOWER, TRIM, CONCAT, SYSDATE, ROUND와 같은 함수를 의미

※Case문에서 ELSE를 생략할 경우, ELSE조건이 만족하게 되면 NULL이 된다.

※외래키 관계로 있고 on delete cascade가 설정돼 있는 경우 참조하고 있는 기본키가 포함된 행이 삭제될 경우 종속행도 자동으로 삭제된다.

※DROP COLUMN은 테이블의 칼럼을 삭제하고 한 번에 하나의 칼럼만 삭제 가능하다.

※NEXT_DAY함수는 지정된 요일의 첫 번째 날짜를 출력한다.

※ADD_MONTHS( (date, num), 'N요일') : 해당 date의 num개월 후 N요일을 출력한다.

※(날짜1 - 날짜2)의 결과는 일수가 나온다.

※"=" 연산자가 아닌 다른 연산자를 사용할 조인은 모두 NON EQUI JOIN이 된다.

※Inline View는 특정 건수의 데이터만 조회하기 위해서 사용된다. (MSSQL의 top, MySQL의 limit과 유사)

※ROWNUM은 Oracle에서 사용되는 것이다. 

※그룹함수를 사용하는 경우 NULL값은 연산에서 제외된다. 따라서 NVL함수를 사용하는 것은 합계오류를 예방하는 것과는 전혀 관계가 없다.

※LTRIM('A', 'B') : 좌측 인자값 'A'에서 맨 왼쪽부터 검사해 우측 인자값을 제거하는 함수. 처음에 시작하는 인자값이 'B'의 인자 중 어느 하나도 포함하지 않는 경우 'B'의 값을 읽지 않고 값을 그대로 반환한다.

※CHAR(고정길이 문자형)은 비교시 서로 길이가 다르면 짧은 쪽에 스페이스를 추가해 같은 값으로 판단한다. 길이로 다르게 판단하는 건 VARCHAR(가변길이 문자형)이다.

※연산자 실행 순서는 괄호, NOT, 비교연산자, AND, OR 순이다. 

※IN( ) 연산자의 ( ) 안에 NULL이 있으면 NULL에 대해서는 비교연산을 수행하지 않는다.

※집계함수에서 count(*) 함수는 조건절이 거짓일 때 0을 반환한다.