

# 190813 Linux

## 복습

**#셸 명령어**

- echo : 배시 셸의 한 줄의 문자열 출력

- printf : 배시 셸의 한줄의 문자열을 %지시자와 W문자를 이용해 출력 형식을 지정
-  stdin 0 : 표준입력 파일 디스크립터
- stdout 1 : 표준출력 파일 디스크립터
- stderr : 표준오류 파일 디스크립터
- 출력 리다이렉션 ">" : 기존 파일의 내용을 삭제하고 새로 결과를 저장
  - ls -l > ls.out 
- 출력 리다이렉션 ">>" : 기존 파일의 내용 뒤에 추가 저장.
  - ls -l >> ls.in

- set : 셸 변수, 환경 변수 모두 출력

  - 셸 변수와 환경 변수 :  자주 필요한 정보를 저장하여 사용자가 사용하기 편리하게 해주는 것, 프로세스가 컴퓨터에서 동작하는 방식에 영향을 미치는 동적인 값들의 모임이다.
  - 셸 변수 : 현재 셸에서만 사용 가능, 서브 셸로는 전달되지 않음
  - 환경 변수 : 현재 셸에서 사용 가능, 서브 셸로도 전달 가능

- env : 환경 변수만 출력

  - 미리 정의된 환경변수들 : HISTSIZE, HOME, LANG, PATH, PWD, SHELL 등

  | 환경변수 이름 |                            뜻                             |
  | :-----------: | :-------------------------------------------------------: |
  |     PATH      | 명령어 검색 경로, 보통 쉘 설정 파일들 중 하나에 설정된다. |
  |    EDITOR     |                   자주 이용하는 편집기                    |
  |    PRINTER    | 기본 프린터(설정이 되어있으면 lpr에게 알려주지 않아도 됨) |
  |      PWD      |                현재 디렉토리의 절대경로명                 |
  |     HOME      |                    사용자 홈 디렉토리                     |
  |     SHELL     |                  로그인 쉘의 절대경로명                   |
  |     USER      |                        사용자 이름                        |
  |     TERM      |                    터미널 종류의 이름                     |
  |    TERMCAP    |     터미널 종류에 대한 termcap 데이터베이스 항목 로드     |





**#기본 사용법**

- 셸변수 정의(설정) : 변수명 = 문자열
- 정의된 셸변수를 환경변수로 설정 : export 변수명=문자열, export 변수명
- 환경변수를 다시 셸변수로 바꾸려면 : export -n
- 기존 명령을 대신해서 다른 이름을 붙여 사용하려면 : alias 이름='명령'
- alias 설정 해제 : unalias
- 사용자가 이전에 입력한 명령을 다시 불러와서 사용하려면 : history
- 바로 직전에 사용했었던 명령을 재실행하려면 : !!
- 히스토리에서 해당 번호의 명령을 재실행하려면 : !번호
- 히스토리에서 문자열로 시작하는 명령 중에서 마지막에 실행된 명령을 재실행하려면 : !문자열





**#배시셸에서 시스템 환경 설정 파일**

- /etc/profile : 모든 셸에 공통으로 적용되는 환경설정, bash.bashrc 파일을 실행시킴
- /etc/bash.bashrc  : 기본 프롬프트 설정, 시스템에 공통으로 적용되는 환경 설정
- /etc/profile.d/*.sh : 언어나 명령어별로 필요한 환경을 설정





**#배시셸에서 사용자의 환경 설정 파일**

- ~/.profile : 사용자가 정의하는 환경 설정, .bashrc 파일을 실행시킴
- ~/.bashrc : 히스토리의 크기 설정, alias 설정, 함수 설정
- ~/.bash_aliases : 사용자가 정의한 alias를 별도 파일로 저장
- ~/.bash_logout : 로그아웃할 때 필요한 함수들을 설정





**#ls -l 옵션으로 출력 내용**

- "-" 또는"d" : 파일의 종류
- rwxrwxrwx
  - 첫번째 rwx : 소유자의 파일 접근 권한
  - 두번째 rwx : 소유자가 속한 그룹의 파일 접근 권한
  - 세번째 rwx : 다른 사용자들의 파일 접근 권한 

- 하드링크 개수
- 소유자 ID
- 소유자의 그룹 이름
- 파일 크기
- 파일이 마지막 수정된 날짜와 시간
- 파일명





**#파일 접근 권한**

- chmod : 파일 접근 권한 변경
- chmod -R : 하위 디렉토리까지 파일 접근 권한 변경
  - 기호 모드 : +(권한추가), -(권한빼기), r(읽기), w(쓰기), x(실행)
  - 숫자 모드 :  chmod 777, chmod 644, ...

- umask : 기본 접근 권한 확인, 기본 접근 권한 변경
  - 기본 접근 권한을 변경하는 umask는 파일이나 디렉토리 생성시 부여하지 않을 권한을 지정한다.



**#특수 접근 권한** : SetUID, SetGID, sticky bit

- SetUID
  - 맨 앞자리가 4로 설정됨. 
  - SetUID가 설정돼 있는 파일이 실행되는 동안에는 파일을 실행한 사용자 권한이 아니라 파일 소유자의 권한으로 실행됨.
  - 소유자의 실행 권한에 's'로 표시됨
- SetGID
  - 맨 앞자리가 2로 설정됨
  - SetUID가 설정돼 있는 파일이 실행되는 동안에는 파일을 실행한 사용자 권한이 아니라 파일 소유자의 그룹 권한으로 실행됨.
- sticky biy
  - 맨 앞자리가 1로 설정됨
  - 디렉토리에 설정
  - sticky bit가 설정된 디렉토리에는 누구나 파일을 생성 가능, 다른 사용자가 생성한 파일은 삭제 불가
    - 대표적인 예가 /tmp





**#프로세스**

- 데몬 프로세스 : 특정 서비스를 제공하기 위해 존재. 리눅스 커널에 의해 실행
- 고아 프로세스 : 자식 프로세스가 아직 실행 중인데 부모 프로세스가 먼저 종료된 프로세스
- 좀비 프로세스 : 자식 프로세스가 종료했음에도 프로세스 테이블 목록에 남아있는 경우 (defunct 프로세스로 출력됨)



**#프로세스 관련 명령어**

- ps : 현재 실행중인 프로세스의 목록을 보는 명령
- -f : 현재 실행중인 프로세스의 상세 정보 출력
  - UID, PID, PPID, C, STIME, TTY(프로세스의 종류), TIM(프로세스가 작동하는 시간), CMD(프로세스 이름)

- -a : 터미널에서 실행한 프로세스의 정보 출력
  - STAT 필드 : 지금 현재 실행중인지 대기 상태인지
- u 옵션 : 현재 실행 중인 프로세스의 메모리 사용량 출력
  - %CPU, %MEM, VSZ, RSS, ...

- pgrep : 실행중인 특정 프로세스 정보 검색
- kill [-시그널] pid : 프로세스 강제 종료

- pkill : 프로세스이름으로 강제 종료
- jobs : 현재 실행중인 모든 작업을 봄
- 백그라운드, 포그라운드 작업
  - ctrl + z
  - stop %작업번호
  - bg %작업번호 : 백그라운드로 전환
  - fg %작업번호 : 포그라운드로 전환

- at [옵션] 시간 : 특정 시간에 작업을 한번만 수행하도록 예약
  - ex) at 12pm + 2 days, at 12am tomorrow, at 2pm today, ....
- crontab : 정해진 시간에 작업을 반복적으로 수행하도록 예약 
  - 분 시 일 월 요일  작업내용







--------------------------------

# I. 파일시스템과 디스크 관리하기



## 01. 리눅스 파일 시스템의 종류

#**파일 시스템**

- 파일과 디렉터리의 집합을 구조적으로 관리하는 체계

- 어떤 구조를 구성하여 파일이나 디렉터리를 관리하느냐에 따라 다양한 형식의 파일 시스템이 존재



#**리눅스** **고유의 디스크 기반 파일** **시스템**

- ext(ext1)

  - Extended File System’의 약자로  1992년 4월 리눅스 0.96c에 포함되어 발표

  - 파일 시스템의 최대 크기는 2GB, 파일 이름의 길이는 255바이트까지 지원

  - inode 수정과 데이터의 수정 시간 지원이 안 되고, 파일 시스템이 복잡해지고 파편화되는 문제

  - 현재 리눅스에서는 ext 파일 시스템을 사용하지 않음

- ext2
  - ext 파일 시스템이 가지고 있던 문제를 해결하고, 1993년 1월 발표
  - ext2는 ext3 파일 시스템이 도입되기 전까지 사실상 리눅스의 표준 파일 시스템으로 사용

  - 이론적으로 32TB까지 가능

- ext3

  - ext3는 ext2를 기반으로 개발되어 호환이 가능하며 2001년 11월 공개

  - ext3의 가장 큰 장점은 저널링(journaling) 기능을 도입 복구기능 강화
    - 저널링 : 파일 시스템에 문제가 생기면 따로 기록을 해놓는 기능
  - 파일 시스템의 최대 크기는 블록의 크기에 따라 2~32TB까지 지원

- ext4
  - ext4 파일 시스템은 1EB(엑사바이트, 1EB=1,024×1,024TB) 이상의 볼륨과 16TB 이상의 파일을 지원

  - ext2 및 ext3와 호환성을 유지하며 2008년 12월 발표

- XFS
  - eXtended File System의 약자

  - 1993년 실리콘그래픽스가 개발한 고성능 저널링 파일 시스템. 2000년 5월 GNU GPL로 공개

  - 2001년 리눅스에 이식되었고 현재 대부분의 리눅스 배포판에서 지원
  - XFS는 64bit 파일 시스템으로 최대 16EB까지 지원





**#리눅스에서 지원하는 다른 디스크 기반 파일 시스템**

![1565658760496](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1565658760496.png)





**#특수 용도의 가상 파일 시스템**

![1565658865301](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1565658865301.png)





#**현재 시스템이 지원하는 파일 시스템** **확인하기**

- /proc/filesystems는 현재 커널이 지원하는 파일 시스템의 종류를 알려줌 (cat, more, less로 확인!)

![1565659108396](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1565659108396.png)

nodev: 해당 파일 시스템이 블록 장치 (예 : 디스크)와 연결되어 있지 않다는 것으로 가상 파일 시스템임을 뜻





## 02. 리눅스 파일 시스템의 구조

#**리눅스의** **모든 파일** **시스템의 기본 개념**

- 파일은 inode로 관리된다.

- 디렉터리는 단순히 파일의 목록을 가지고 있는 파일일 뿐이다.

- 특수 파일을 통해 장치에 접근할 수 있다.



**#ext4 파일 시스템의 구조**

- 효율적으로 디스크를 사용하기 위해 저장 장치를 논리적인 블록의 집합(블록 그룹)으로 구분

- 일반적으로 블록은 4KB이고 실제 크기는 시스템의 설정에 따라 변경 가능

- 블록 그룹 유형
  - 블록 그룹 0 : 파일 시스템의 첫 번째 블록 그룹으로 특별하게 그룹 0 패딩과 슈퍼블록, 그룹 디스크립터를 가지고 있다. 
  - 블록 그룹 a : 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩이 없으나 슈퍼블록과 그룹 디스크립터에 대한 복사본을 가지고 있다.  
  - 블록 그룹 b : 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩, 슈퍼블록, 그룹 디스크립터가 없고 바로 데이터 블록 비트맵으로 시작한다.

![1565659391821](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1565659391821.png)



- 그룹 0 패딩 
  - 블록 그룹 0의 첫 1,024바이트는 특별한 용도로 사용되는데, x86 부트 섹터와 부가 정보를 저장

- 슈퍼블록

  - 파일 시스템과 관련된 다양한 정보가 저장

    –전체 inode의 개수                        • 전체 블록의 개수

    –할당되지 않은 블록(free block)의 개수    • 할당되지 않은 inode(free inode)의 개수 

    –첫 번째 데이터 블록의 주소    • 블록의 크기

    –그룹당 블록의 개수    • 마운트 시간

    –파일 시스템의 생태    • 그룹 디스크립터의 크기

  - 슈퍼블록에 문제가 생길 경우 전체 파일 시스템을 사용할 수 없게 됨
  - 슈퍼블록을 다른 블록 그룹에 복사하고, 블록 그룹 0의 슈퍼블록을 읽을 수 없을 경우 복사본을 사용하여 복구

- 그룹 디스크립터와 GDT 예약 블록

  - 그룹 디스크립터도 블록 그룹 0에 있는 것으로 슈퍼블록의 다음에 위치

  - 그룹 디스크립터에 저장되는 정보

    –블록 비트맵의 주소    •   inode 비트맵의 주소

    –inode 테이블의 주소    •   할당되지 않은 블록의 개수

    –할당되지 않은 inode의 개수    •  디렉터리의 개수

    –블록 비트맵, inode 비트맵 체크섬

- 데이터 블록 비트맵과 inode 비트맵

  - 데이터 블록 비트맵은 블록 그룹에 포함된 데이터 블록의 사용 여부를 확인하는 데 사용

  - inode 비트맵은 inode 테이블의 항목(inode)이 사용 중인지를 표시

- inode 테이블과 데이터 블록
  - inode에는 파일 정보를 저장하고 데이터 블록에는 실제 데이터를 저장





**#inode의 구조**

![1565659563845](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1565659563845.png)





#**파일 시스템과 디렉터리 계층** **구조**

- 디렉터리 계층 구조는 리눅스의 전체 파일과 디렉터리를 어떤 구조로 정리하고 관리할 것인지를 정의한 것

- 실제 파일이 저장되어 있는 파일 시스템은 디렉터리 계층 구조에 연결되어야 사용자가 접근 가능



#**한 파일 시스템으로** **구성하기**

- 디렉터리 계층 구조에서 보이는 모든 디렉터리와 파일을 하나의 파일 시스템으로 구성



#**여러 파일 시스템으로** **구성하기**

- 디렉터리 계층 구조를 여러 파일 시스템으로 구분하여 구성

- 여러 파일 시스템으로 나누어 디렉터리 계층 구조를 구성할 경우, 일부 파일 시스템에 문제가 생기더라도 다른 파일 시스템의 파일은 안전

![1565659726773](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1565659726773.png)







## 03. 파일 시스템 마운트

#**마운트**

- 파일 시스템을 디렉터리 계층 구조의 특정 디렉터리와 연결하는 것



#**마운트** **포인트**

- 디렉터리 계층 구조에서 파일 시스템이 연결되는 디렉터리를 마운트 포인트라고 함



#**파일 시스템** **마운트** **설정** **파일**

- 리눅스에서 시스템이 부팅될 때 자동으로 파일 시스템이 마운트되게 하려면 /etc/fstab 파일에 설정

- /etc/fstab 파일의 기능: 파일 시스템의 마운트 설정 정보 저장

![1565659782697](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1565659782697.png)



**#/etc/fstab 파일의 구조**

![1565659867796](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1565659867796.png)



- /etc/fstab 파일의 예
  - 장치명 : UUID=7009cb18-dbd5-4ffc-af86-599cee765454
  - 마운트 포인트 : /

  - 파일 시스템의 종류 : ext4 

  - 옵션 : errors=remount-ro
  - 덤프 관련 설정 : 1
  - 파일 점검 옵션 : 1 

- UUID는  ‘universally unique identifier’의 약자로 로컬 시스템과 다른 시스템에서 파일 시스템을 유일하게 구분해주는 128비트의 숫자
  - UUID는 시스템의 하드웨어 정보와 시간 정보를 조합하여 랜덤으로 생성
  - UUID로 지정된 장치는 /dev/disk/by-uuid 디렉터리에서 찾을 수 있음

- 장치명: 파일 시스템 장치명, 예를 들어 /dev/hda1, /dev/sda1과 같이 특정 디스크를 지정

- 마운트 포인트: 파일 시스템이 마운트될 마운트 포인트를 설정

- 파일 시스템의 종류:  파일 시스템의 종류를 설정, ext2, ext3, ext4 외

- 옵션: 파일 시스템의 속성을 지정

- 덤프 관련 설정: 0(dump 불가)

  ​	                        1(dump 가능)

- 파일 점검 옵션
  - 0: 부팅시 fsck 안함

  - 1: 루트 파일 시스템
  - 2: 루트 파일 시스템 이외 

![1565659917094](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1565659917094.png)



