# 190910 R

## I. 데이터 시각화

### 1. 산점도(scatter plot) 

> 두 개 이상의 변수들 사이의 분포를 점으로 표시한 차트로, 두 변수의 관계를 시각적으로 분석할 때 유용하다.

```R
# 변수 생성
> price <- runif(10, min=1, max=100)
> print(price)
 [1] 44.58740 16.87671 51.20836 71.45749
 [5] 29.50702 72.73759 96.15604 88.70070
 [9] 75.69529 32.31233

# 플롯 차트 생성
> plot(price, col="red")
> par(new=T) # 차트 추가
> line_chart=1:100

# x축은 생성된 난수의 순서, y축은 
> plot(line_chart, type="l", col="red", axes=F, ann=F) #대각선 추가
```

![1](190910%20R.assets/1.JPG)



#### 1) 좌표평면상의 점 등을 선으로 연결

```R
> par(mfrow=c(2,2))
> plot(price, type="l")  # 실선
> plot(price, type="o")  #원형과 실선
> plot(price, type="h")  #직선
> plot(price, type="s")  #꺽은선
```

![2](190910%20R.assets/2.JPG)



#### 2) plot점 크기 확대

- 중복된 데이터의 수만큼  점 크기 확대

```R
> y<-rep(2, 6)
> table(x, y)  # 빈도수
   y
x   2
  1 1
  2 2
  3 1
  4 2

# 깔끔하게 테이블로
> xy.df <- as.data.frame(table(x, y))
> xy.df
  x y Freq
1 1 2    1
2 2 2    2
3 3 2    1
4 4 2    2

> par(mfrow=c(1,1))
> plot(x, y, pch='@', col='skyblue', 
       cex=0.5*xy.df$Freq, xlab="x벡터 원소",
       ylab="y벡터 원소")

# 빈도수에 따라 플롯의 크기가 다른 모습을 확인할 수 있다.
```

![3](190910%20R.assets/3.JPG)



```R
# 내장 데이터 불러오기 위한 패키지 설치 후 데이터 확인
> install.packages("psych")
> library(psych)
> data(galton)


# child컬럼, parent컬럼을 대상으로 교차테이블을 생성 결과를 데이터프레임으로 생성
> data(galton)
> galtondf <- as.data.frame(table(galton$child, galton$parent))
> head(galtondf)
  Var1 Var2 Freq
1 61.7   64    1
2 62.2   64    0
3 63.2   64    2
4 64.2   64    4
5 65.2   64    1
6 66.2   64    2
> str(galtondf)
'data.frame':	154 obs. of  3 variables:
 $ Var1: Factor w/ 14 levels "61.7","62.2",..: 1 2 3 4 5 6 7 8 9 10 ...
 $ Var2: Factor w/ 11 levels "64","64.5","65.5",..: 1 1 1 1 1 1 1 1 1 1 ...
 $ Freq: int  1 0 2 4 1 2 2 1 1 0 ...


# 컬럼명 변경 (names(데이터객체) <- c(벡터))
> names(galtondf) <- c("child", "parent", "freq")
> head(galtondf)
  child parent freq
1  61.7     64    1
2  62.2     64    0
3  63.2     64    2
4  64.2     64    4
5  65.2     64    1
6  66.2     64    2


# Factor로 돼 있는 자료형은 numeric으로 형변환
> parent <- as.numeric(galtondf$parent)
> child <- as.numeric(galtondf$child)


# 차트 생성
> plot(parent, child, pch=21, col="blue", bg="green",
       cex=0.2*galtondf$freq, xlab="parent", ylab="child")
```

![4](190910%20R.assets/4.JPG)



#### 3) pairs()

> 변수 간의 관계를 차트로 그릴 수 있다.  graphics패키지에서 제공하는 paris()는 matrix 또는 data.frame의 
> numeric 컬럼을 대상으로 변수들 사이의 비교 결과를 행렬구조의 분산된 그래프로 제공한다.

```R
# iris 데이터셋 정보 확인
> attributes(iris)
$names
[1] "Sepal.Length" "Sepal.Width" 
[3] "Petal.Length" "Petal.Width" 
[5] "Species"     

$class
[1] "data.frame"

$row.names
  [1]   1   2   3   4   5   6   7   8   9
 [10]  10  11  12  13  14  15  16  17  18
 [19]  19  20  21  22  23  24  25  26  27
 [28]  28  29  30  31  32  33  34  35  36
 [37]  37  38  39  40  41  42  43  44  45
 [46]  46  47  48  49  50  51  52  53  54
 [55]  55  56  57  58  59  60  61  62  63
 [64]  64  65  66  67  68  69  70  71  72
 [73]  73  74  75  76  77  78  79  80  81
 [82]  82  83  84  85  86  87  88  89  90
 [91]  91  92  93  94  95  96  97  98  99
[100] 100 101 102 103 104 105 106 107 108
[109] 109 110 111 112 113 114 115 116 117
[118] 118 119 120 121 122 123 124 125 126
[127] 127 128 129 130 131 132 133 134 135
[136] 136 137 138 139 140 141 142 143 144
[145] 145 146 147 148 149 150

> pairs(iris[, 1:4])
```

![5](190910%20R.assets/5.JPG)



- 특정 컬럼에 대해서만 변수 관계 시각화

```R
> pairs(iris[iris$Species=="setosa", 1:4])
```

![6](190910%20R.assets/6.JPG)



#### 4) 3차원 산점도

> scatterplot3d (밑변, 오른쪽변 컬럼명, 왼쪽변 컬럼명)

```R
# 3차원 산점도 패키지 설치 및 적용
> install.packages("scatterplot3d")
> library(scatterplot3d)

> levels(iris$Species)
[1] "setosa"     "versicolor"
[3] "virginica" 
> iris_setosa = iris[iris$Species=='setosa', ]
> iris_versicolor = iris[iris$Species=='versicolor', ]
> iris_virginica = iris[iris$Species=='virginica', ]

# 3차원 산점도를 위한 3차원 구조를 먼저 생성
> d3 <- scatterplot3d(iris$Petal.Length, iris$Sepal.Length,
                      iris$Sepal.Width, type='n') # type='n'은 기본 산점도를 표시하지 않음

# setosa, versicolor, virginica의 산점도를 추가
> d3$points3d(iris_setosa$Petal.Length, iris_setosa$Sepal.Length, 
              iris_setosa$Sepal.Width, bg="orange", pch=21)
> d3$points3d(iris_versicolor$Petal.Length, iris_versicolor$Sepal.Length, 
              iris_versicolor$Sepal.Width, bg="blue", pch=23)
> d3$points3d(iris_virginica$Petal.Length, iris_virginica$Sepal.Length, 
              iris_virginica$Sepal.Width, bg="green", pch=25)
```

![7](190910%20R.assets/7.JPG)



--------

## II. 유용한 패키지

> - 데이터 분석에서는 70% 이상의 시간이 데이터 변환과 조작, 필터링 등 전처리 작업에 소요된다.
>
> - 데이터 전처리에 사용되는 유용한 패키지 : plyr, dplyr, reshape, reshape2 패키지 등



### 1. plyr 패키지

> 두 개 이상의 데이터프레임을 대상으로 key값을 이용해 merge, 함수적용, 요약 집계 등의 기능을 제공한다.



#### 1) merge

```R
# 패키지 설치 및 적용
> install.packages("plyr")
> library(plyr)

# 샘플 데이터 생성
> x <- data.frame(id=c(1, 2, 3, 4, 5), height=c(160, 171, 173, 162, 165))
> y <- data.frame(id=c(5, 1, 4, 2, 3), weight=c(55, 73, 65, 48, 85))

# join() : 두 데이터 프레임을 merge
> xyjoin <- join(x, y, by="id") # by옵션에 무엇을 기준으로 조인할지 적어준다.
> xyjoin
  id height weight
1  1    160     73
2  2    171     48
3  3    173     85
4  4    162     65
5  5    165     55

# 샘플 데이터의 키 값을 다르게 수정
> x <- data.frame(id=c(1, 2, 3, 4, 6), height=c(160, 171, 173, 162, 165))
> y <- data.frame(id=c(5, 1, 4, 2, 3), weight=c(55, 73, 65, 48, 85))


# 왼쪽 데이터 프레임의 키값을 기준으로 merge
> leftjoin <- join(x, y, by="id") 
> leftjoin  # 키에 조인할 데이터가 없으면 NA로 출력
  id height weight
1  1    160     73
2  2    171     48
3  3    173     85
4  4    162     65
5  6    165     NA


# innerjoin은 두 데이터프레임에서 키값이 있는 경우에만 조인을 수행
> innerjoin <- join(x, y, by="id", type="inner")
> innerjoin   
  id height weight
1  1    160     73
2  2    171     48
3  3    173     85
4  4    162     65


# 키 값이 존재하는 전체 관측치를 대상으로 조인 수행, 키에 join할 데이터가 없으면 NA로 출력
> fulljoin <- join(x, y, by="id", type="full")
> fulljoin   
  id height weight
1  1    160     73
2  2    171     48
3  3    173     85
4  4    162     65
5  6    165     NA
6  5     NA     55


# 연습
> x<-data.frame(key1=c(1, 1, 2, 2, 3), 
                key2=c('a', 'b', 'c', 'd', 'e'),
                val1 = c(10, 20, 30, 40, 50)) 
> y<-data.frame(key1=c(3, 2, 2, 1, 1), 
                key2=c('e', 'd', 'c', 'b', 'a'),
                val2 = c(500, 300, 400, 100, 200))
 
> xyjoin <- join (x, y, by=c('key1', 'key2'))
> xyjoin
  key1 key2 val1 val2
1    1    a   10  200
2    1    b   20  100
3    2    c   30  400
4    2    d   40  300
5    3    e   50  500
```



#### 2) apply

- apply(vec, func) : 결과는 벡터, 배열, 리스트
- lapply(vec|list, func) : 결과는  리스트
- sapply(vec, func) : 결과는 벡터, 배열, 행렬 반환
- tapply() : 데이터 셋에 집단 변수(이산형 범주)를 대상으로 그룹별 함수 적용
  - tapply(dataset, 집단변수, 함수)

```R
> names(iris)
[1] "Sepal.Length" "Sepal.Width" 
[3] "Petal.Length" "Petal.Width" 
[5] "Species"     

> unique(iris$Species)
[1] setosa     versicolor virginica 
3 Levels: setosa ... virginica

# iris데이터셋에서 Sepal 길이를 Species를 기준으로 각각 mean함수를 적용해준다. 
> tapply(iris$Sepal.Length, iris$Species, mean)
    setosa versicolor  virginica 
     5.006      5.936      6.588 

# iris데이터셋에서 Sepal 길이를 Species를 기준으로 각각 sd함수를 적용해준다. 
> tapply(iris$Sepal.Length, iris$Species, sd)
    setosa versicolor  virginica 
 0.3524897  0.5161711  0.6358796 
```



- ddply() : 데이터 셋에 집단 변수(이산형 범주)를 대상으로 그룹별 함수 "여러개" 적용
  - ddply(dataset, 집단변수, 요약집계, 컬럼명=함수(변수)) 

```R
> avg_df <- ddply(iris, .(Species), summarise, avg=mean(Sepal.Length))
# .(Species)는 현재 데이터셋(=iris)의 Species라는 집단변수를 의미한다.
# avg=mean(Sepal.Length)는 avg라는 컬럼명으로 Sepal.Length라는 변수에 mean함수를 적용한 값을 저장하는 것이다.


> avg_df
     Species   avg
1     setosa 5.006
2 versicolor 5.936
3  virginica 6.588

> str(avg_df)  #ddply함수는 dataframe 형식으로 결과를 리턴한다.
'data.frame':	3 obs. of  2 variables:
 $ Species: Factor w/ 3 levels "setosa","versicolor",..: 1 2 3
 $ avg    : num  5.01 5.94 6.59


# 확인하고 싶은 값이 더 있으면 뒤에 '컬럼명=함수(변수)' 형식으로 나열해주면 된다.
> result <- ddply(iris, .(Species), summarise, avg=mean(Sepal.Length), 
                  std = sd(Sepal.Length), max=max(Sepal.Length),
                  min=min(Sepal.Length))

> result
     Species   avg       std max min
1     setosa 5.006 0.3524897 5.8 4.3
2 versicolor 5.936 0.5161711 7.0 4.9
3  virginica 6.588 0.6358796 7.9 4.9

> str(result)
'data.frame':	3 obs. of  5 variables:
 $ Species: Factor w/ 3 levels "setosa","versicolor",..: 1 2 3
 $ avg    : num  5.01 5.94 6.59
 $ std    : num  0.352 0.516 0.636
 $ max    : num  5.8 7 7.9
 $ min    : num  4.3 4.9 4.9
```



### 2. dplyr 패키지

> 데이터 전처리( 조건 필터, 그룹핑,  함수적용, 변환, 집계연산, 정렬,.....)

- filter() : 조건에 맞는 데이터셋 추출, 행추출
  - filter(dataframe, 조건1, 조건2)
- select() : 데이터 셋을 대상으로 컬럼을 선택하는 기능
  - select(dataframe, 컬럼1, 컬럼2,...)
- mutate() : 데이터 넷의 새로운 컬럼을 추가하는 기능
  - mutate(dataframe, 컬럼명1=표현식, 컬럼명2=표현식, ...)
- arrange() : 데이터 셋의 특정 컬럼으로 정렬하는 기능
  - arrange(dataframe,컬럼, desc(컬럼), ...)
- summarise() : 데이터 셋의 특정 컬럼으로 요약집계 기능
  - summarise(dataframe, 추가컬럼명=함수(컬럼명), ...)

- tbl_df() : 데이터셋에서 콘솔 창의 크기만큼 데이터셋 추출 가능
- group_by() : 클래스별로 기초 통계값을 출력
  - group_by(dataframe, 집단변수)

```R
# exam.csv파일 읽어와서 저장 및 확인
> exam <- read.csv("./data/exam.csv")
> print(exam)
   id class math english science
1   1     1   50      98      50
2   2     1   60      97      60
3   3     1   45      86      78
4   4     1   30      98      58
5   5     2   25      80      65
6   6     2   50      89      98
7   7     2   80      90      45
8   8     2   90      78      25
9   9     3   20      98      15
10 10     3   50      98      45
11 11     3   65      65      65
12 12     3   45      85      32
13 13     4   46      98      65
14 14     4   48      87      12
15 15     4   75      56      78
16 16     4   58      98      65
17 17     5   65      68      98
18 18     5   80      78      90
19 19     5   89      68      87
20 20     5   78      83      58

> str(exam)
'data.frame':	20 obs. of  5 variables:
 $ id     : int  1 2 3 4 5 6 7 8 9 10 ...
 $ class  : int  1 1 1 1 2 2 2 2 3 3 ...
 $ math   : int  50 60 45 30 25 50 80 90 20 50 ...
 $ english: int  98 97 86 98 80 89 90 78 98 98 ...
 $ science: int  50 60 78 58 65 98 45 25 15 45 ...
```



#### 1) 파이프 연산자 활용하기

```R
# %>% 파이프 연산자(다음 함수의 입력값으로 전달)
# class가 1인 레코드(행) 추출
> class1 <- exam %>% filter(class==1)
> print(class1)
  id class math english science
1  1     1   50      98      50
2  2     1   60      97      60
3  3     1   45      86      78
4  4     1   30      98      58


# class가 1인 레코드를 제외한 레코드 추출
> other_class <- exam %>% filter(class!=1)
> print(other_class)
   id class math english science
1   5     2   25      80      65
2   6     2   50      89      98
3   7     2   80      90      45
4   8     2   90      78      25
5   9     3   20      98      15
6  10     3   50      98      45
7  11     3   65      65      65
8  12     3   45      85      32
9  13     4   46      98      65
10 14     4   48      87      12
11 15     4   75      56      78
12 16     4   58      98      65
13 17     5   65      68      98
14 18     5   80      78      90
15 19     5   89      68      87
16 20     5   78      83      58


# class가 1이면서 수학점수는 50이상인 행을 추출
> class_math50 <- exam %>% filter(class==1 & math>50)
> print(class_math50)
  id class math english science
1  2     1   60      97      60


# class가 1, 3, 5인 행만 추출
> odd_class <- exam %>% filter(class %in% c(1, 3, 5))
> print(odd_class)
   id class math english science
1   1     1   50      98      50
2   2     1   60      97      60
3   3     1   45      86      78
4   4     1   30      98      58
5   9     3   20      98      15
6  10     3   50      98      45
7  11     3   65      65      65
8  12     3   45      85      32
9  17     5   65      68      98
10 18     5   80      78      90
11 19     5   89      68      87
12 20     5   78      83      58


# 영어점수 컬럼값만 추출
> e_jumsu <- exam %>% select(english)
> print(e_jumsu)
   english
1       98
2       97
3       86
4       98
5       80
6       89
7       90
8       78
9       98
10      98
11      65
12      85
13      98
14      87
15      56
16      98
17      68
18      78
19      68
20      83


# 수학점수 제외하고 모든 컬럼 추출
> all_column <- exam %>% select(-math)
> print(all_column)
   id class english science
1   1     1      98      50
2   2     1      97      60
3   3     1      86      78
4   4     1      98      58
5   5     2      80      65
6   6     2      89      98
7   7     2      90      45
8   8     2      78      25
9   9     3      98      15
10 10     3      98      45
11 11     3      65      65
12 12     3      85      32
13 13     4      98      65
14 14     4      87      12
15 15     4      56      78
16 16     4      98      65
17 17     5      68      98
18 18     5      78      90
19 19     5      68      87
20 20     5      83      58


# class가 1이면서 영어점수 컬럼값만 1행에서 3행까지 출력
> print(exam %>% filter(class==1) %>% select(english) %>% head(3))
  english
1      98
2      97
3      86


# 수학점수를 기준으로 오름차순 정렬된 결과를 변수에 저장하고 출력
> asc_math <- exam %>% arrange(math)
> print(asc_math)
   id class math english science
1   9     3   20      98      15
2   5     2   25      80      65
3   4     1   30      98      58
4   3     1   45      86      78
5  12     3   45      85      32
6  13     4   46      98      65
7  14     4   48      87      12
8   1     1   50      98      50
9   6     2   50      89      98
10 10     3   50      98      45
11 16     4   58      98      65
12  2     1   60      97      60
13 11     3   65      65      65
14 17     5   65      68      98
15 15     4   75      56      78
16 20     5   78      83      58
17  7     2   80      90      45
18 18     5   80      78      90
19 19     5   89      68      87
20  8     2   90      78      25


# 수학점수를 기준으로 내림차순 정렬된 결과를 변수에 저장하고 출력
> desc_math <- exam %>% arrange(desc(math))  #dplyr패키지의 내장함수에 desc함수가 있다!
> print(desc_math)
   id class math english science
1   8     2   90      78      25
2  19     5   89      68      87
3   7     2   80      90      45
4  18     5   80      78      90
5  20     5   78      83      58
6  15     4   75      56      78
7  11     3   65      65      65
8  17     5   65      68      98
9   2     1   60      97      60
10 16     4   58      98      65
11  1     1   50      98      50
12  6     2   50      89      98
13 10     3   50      98      45
14 14     4   48      87      12
15 13     4   46      98      65
16  3     1   45      86      78
17 12     3   45      85      32
18  4     1   30      98      58
19  5     2   25      80      65
20  9     3   20      98      15


# 1차 정렬은 class의 오름차순, 2차 정렬은 수학점수의 내림차순으로 정렬
> order_math <- exam %>% arrange(class, desc(math))  # arrange(1차 정렬 기준, 2차 정렬 기준)
> print(order_math)
   id class math english science
1   2     1   60      97      60
2   1     1   50      98      50
3   3     1   45      86      78
4   4     1   30      98      58
5   8     2   90      78      25
6   7     2   80      90      45
7   6     2   50      89      98
8   5     2   25      80      65
9  11     3   65      65      65
10 10     3   50      98      45
11 12     3   45      85      32
12  9     3   20      98      15
13 15     4   75      56      78
14 16     4   58      98      65
15 14     4   48      87      12
16 13     4   46      98      65
17 19     5   89      68      87
18 18     5   80      78      90
19 20     5   78      83      58
20 17     5   65      68      98


# 총점(수학 + 영어 + 과학) 열을 추가
> new_exam <- exam %>% mutate(total = math + english + science)
> print(new_exam)
   id class math english science total
1   1     1   50      98      50   198
2   2     1   60      97      60   217
3   3     1   45      86      78   209
4   4     1   30      98      58   186
5   5     2   25      80      65   170
6   6     2   50      89      98   237
7   7     2   80      90      45   215
8   8     2   90      78      25   193
9   9     3   20      98      15   133
10 10     3   50      98      45   193
11 11     3   65      65      65   195
12 12     3   45      85      32   162
13 13     4   46      98      65   209
14 14     4   48      87      12   147
15 15     4   75      56      78   209
16 16     4   58      98      65   221
17 17     5   65      68      98   231
18 18     5   80      78      90   248
19 19     5   89      68      87   244
20 20     5   78      83      58   219


# 평균 열 추가
> avg_exam <- new_exam %>% mutate(mean = (math + english + science)/3)
> print(avg_exam)
   id class math english science total     mean
1   1     1   50      98      50   198 66.00000
2   2     1   60      97      60   217 72.33333
3   3     1   45      86      78   209 69.66667
4   4     1   30      98      58   186 62.00000
5   5     2   25      80      65   170 56.66667
6   6     2   50      89      98   237 79.00000
7   7     2   80      90      45   215 71.66667
8   8     2   90      78      25   193 64.33333
9   9     3   20      98      15   133 44.33333
10 10     3   50      98      45   193 64.33333
11 11     3   65      65      65   195 65.00000
12 12     3   45      85      32   162 54.00000
13 13     4   46      98      65   209 69.66667
14 14     4   48      87      12   147 49.00000
15 15     4   75      56      78   209 69.66667
16 16     4   58      98      65   221 73.66667
17 17     5   65      68      98   231 77.00000
18 18     5   80      78      90   248 82.66667
19 19     5   89      68      87   244 81.33333
20 20     5   78      83      58   219 73.00000


# pass 이름의 열을 추가 (평균이 60점 이상이면 "pass" 값, 60점 미만이면 "fail" 값)
> pass_exam <- avg_exam %>% mutate(pass = ifelse(mean>=60, "pass", "fail"))
> print(pass_exam)
   id class math english science total     mean pass
1   1     1   50      98      50   198 66.00000 pass
2   2     1   60      97      60   217 72.33333 pass
3   3     1   45      86      78   209 69.66667 pass
4   4     1   30      98      58   186 62.00000 pass
5   5     2   25      80      65   170 56.66667 fail
6   6     2   50      89      98   237 79.00000 pass
7   7     2   80      90      45   215 71.66667 pass
8   8     2   90      78      25   193 64.33333 pass
9   9     3   20      98      15   133 44.33333 fail
10 10     3   50      98      45   193 64.33333 pass
11 11     3   65      65      65   195 65.00000 pass
12 12     3   45      85      32   162 54.00000 fail
13 13     4   46      98      65   209 69.66667 pass
14 14     4   48      87      12   147 49.00000 fail
15 15     4   75      56      78   209 69.66667 pass
16 16     4   58      98      65   221 73.66667 pass
17 17     5   65      68      98   231 77.00000 pass
18 18     5   80      78      90   248 82.66667 pass
19 19     5   89      68      87   244 81.33333 pass
20 20     5   78      83      58   219 73.00000 pass


# 추가된 평균 컬럼으로 내림차순 정렬
> desc_avg <- pass_exam %>% arrange(desc(mean))
> print(desc_avg)
   id class math english science total     mean pass
1  18     5   80      78      90   248 82.66667 pass
2  19     5   89      68      87   244 81.33333 pass
3   6     2   50      89      98   237 79.00000 pass
4  17     5   65      68      98   231 77.00000 pass
5  16     4   58      98      65   221 73.66667 pass
6  20     5   78      83      58   219 73.00000 pass
7   2     1   60      97      60   217 72.33333 pass
8   7     2   80      90      45   215 71.66667 pass
9   3     1   45      86      78   209 69.66667 pass
10 13     4   46      98      65   209 69.66667 pass
11 15     4   75      56      78   209 69.66667 pass
12  1     1   50      98      50   198 66.00000 pass
13 11     3   65      65      65   195 65.00000 pass
14  8     2   90      78      25   193 64.33333 pass
15 10     3   50      98      45   193 64.33333 pass
16  4     1   30      98      58   186 62.00000 pass
17  5     2   25      80      65   170 56.66667 fail
18 12     3   45      85      32   162 54.00000 fail
19 14     4   48      87      12   147 49.00000 fail
20  9     3   20      98      15   133 44.33333 fail
```





#### 2) 실제 데이터로 실습

- hflights 데이터

```R
> install.packages("hflights")
> library(hflights)
# 2011년도 미국 휴스턴 출발 모든 비행기의 이착률 정보 기록(대략 22만건, 21개의 변수(컬럼)으로 구성됨

> str(hflights)
'data.frame':	227496 obs. of  21 variables:
 $ Year             : int  2011 2011 2011 2011 2011 2011 2011 2011 2011 2011 ...
 $ Month            : int  1 1 1 1 1 1 1 1 1 1 ...
 $ DayofMonth       : int  1 2 3 4 5 6 7 8 9 10 ...
 $ DayOfWeek        : int  6 7 1 2 3 4 5 6 7 1 ...
 $ DepTime          : int  1400 1401 1352 1403 1405 1359 1359 1355 1443 1443 ...
 $ ArrTime          : int  1500 1501 1502 1513 1507 1503 1509 1454 1554 1553 ...
 $ UniqueCarrier    : chr  "AA" "AA" "AA" "AA" ...
 $ FlightNum        : int  428 428 428 428 428 428 428 428 428 428 ...
 $ TailNum          : chr  "N576AA" "N557AA" "N541AA" "N403AA" ...
 $ ActualElapsedTime: int  60 60 70 70 62 64 70 59 71 70 ...
 $ AirTime          : int  40 45 48 39 44 45 43 40 41 45 ...
 $ ArrDelay         : int  -10 -9 -8 3 -3 -7 -1 -16 44 43 ...
 $ DepDelay         : int  0 1 -8 3 5 -1 -1 -5 43 43 ...
 $ Origin           : chr  "IAH" "IAH" "IAH" "IAH" ...
 $ Dest             : chr  "DFW" "DFW" "DFW" "DFW" ...
 $ Distance         : int  224 224 224 224 224 224 224 224 224 224 ...
 $ TaxiIn           : int  7 6 5 9 9 6 12 7 8 6 ...
 $ TaxiOut          : int  13 9 17 22 9 13 15 12 22 19 ...
 $ Cancelled        : int  0 0 0 0 0 0 0 0 0 0 ...
 $ CancellationCode : chr  "" "" "" "" ...
 $ Diverted         : int  0 0 0 0 0 0 0 0 0 0 ...


# 현재 R콘솔 창 크기에서 볼 수 있는 만큼 10개 행, 6개 컬럼
> flights_df <- tbl_df(hflights)
> flights_df
# A tibble: 227,496 x 21
    Year Month DayofMonth DayOfWeek DepTime ArrTime
   <int> <int>      <int>     <int>   <int>   <int>
 1  2011     1          1         6    1400    1500
 2  2011     1          2         7    1401    1501
 3  2011     1          3         1    1352    1502
 4  2011     1          4         2    1403    1513
 5  2011     1          5         3    1405    1507
 6  2011     1          6         4    1359    1503
 7  2011     1          7         5    1359    1509
 8  2011     1          8         6    1355    1454
 9  2011     1          9         7    1443    1554
10  2011     1         10         1    1443    1553
# ... with 227,486 more rows, and 15 more variables:
#   UniqueCarrier <chr>, FlightNum <int>, TailNum <chr>,
#   ActualElapsedTime <int>, AirTime <int>,
#   ArrDelay <int>, DepDelay <int>, Origin <chr>,
#   Dest <chr>, Distance <int>, TaxiIn <int>,
#   TaxiOut <int>, Cancelled <int>,
#   CancellationCode <chr>, Diverted <int>


# 문> hflights 데이터셋으로부터 1월 2일의 모든 비행기의 이착륙 정보 추출
> jan2 <- flights_df %>% filter(Month==1 & DayofMonth==2)
> print(jan2)
# A tibble: 678 x 21
    Year Month DayofMonth DayOfWeek DepTime ArrTime
   <int> <int>      <int>     <int>   <int>   <int>
 1  2011     1          2         7    1401    1501
 2  2011     1          2         7     719     821
 3  2011     1          2         7    1959    2106
 4  2011     1          2         7    1636    1759
 5  2011     1          2         7    1823    2132
 6  2011     1          2         7    1008    1321
 7  2011     1          2         7    1200    1303
 8  2011     1          2         7     907    1018
 9  2011     1          2         7     554     912
10  2011     1          2         7    1823    2103
# ... with 668 more rows, and 15 more variables:
#   UniqueCarrier <chr>, FlightNum <int>, TailNum <chr>,
#   ActualElapsedTime <int>, AirTime <int>, ArrDelay <int>,
#   DepDelay <int>, Origin <chr>, Dest <chr>, Distance <int>,
#   TaxiIn <int>, TaxiOut <int>, Cancelled <int>,
#   CancellationCode <chr>, Diverted <int>



# 문> hflights데이터셋을 년, 월, 출발시간, 도착시간순으로 오름차순 정렬
> asc_flights <- flights_df %>% arrange(Year, Month, DepTime, ArrTime)
> print(asc_flights)
# A tibble: 227,496 x 21
    Year Month DayofMonth DayOfWeek DepTime ArrTime
   <int> <int>      <int>     <int>   <int>   <int>
 1  2011     1          1         6       1     621
 2  2011     1         21         5       4      46
 3  2011     1          4         2       5      59
 4  2011     1         27         4      11     216
 5  2011     1         27         4      17     240
 6  2011     1          9         7      22     117
 7  2011     1         28         5     226     310
 8  2011     1         18         2     537     829
 9  2011     1         25         2     538     824
10  2011     1          7         5     538     832
# ... with 227,486 more rows, and 15 more variables:
#   UniqueCarrier <chr>, FlightNum <int>, TailNum <chr>,
#   ActualElapsedTime <int>, AirTime <int>, ArrDelay <int>,
#   DepDelay <int>, Origin <chr>, Dest <chr>,
#   Distance <int>, TaxiIn <int>, TaxiOut <int>,
#   Cancelled <int>, CancellationCode <chr>, Diverted <int>



# 문> hflights데이터셋을 년(오름차순), 월(오름차순), 출발시간(내림차순), 도착시간(오름차순) 정렬
> depdesc_flights <- flights_df %>% arrange(Year, Month, desc(DepTime), ArrTime)
> print(depdesc_flights)
# A tibble: 227,496 x 21
    Year Month DayofMonth DayOfWeek DepTime ArrTime
   <int> <int>      <int>     <int>   <int>   <int>
 1  2011     1          2         7    2335      32
 2  2011     1          2         7    2334     121
 3  2011     1         27         4    2329      14
 4  2011     1          6         4    2325      10
 5  2011     1         20         4    2325      17
 6  2011     1          3         1    2321     110
 7  2011     1         17         1    2315       8
 8  2011     1         14         5    2315      20
 9  2011     1         27         4    2315    2355
10  2011     1         27         4    2313       3
# ... with 227,486 more rows, and 15 more variables:
#   UniqueCarrier <chr>, FlightNum <int>, TailNum <chr>,
#   ActualElapsedTime <int>, AirTime <int>,
#   ArrDelay <int>, DepDelay <int>, Origin <chr>,
#   Dest <chr>, Distance <int>, TaxiIn <int>,
#   TaxiOut <int>, Cancelled <int>,
#   CancellationCode <chr>, Diverted <int>


# 문> hflights데이터셋으로부터 년, 월, 출발시간, 도착시간 컬럼만 검색
> columns4 <- flights_df %>% select(Year, Month, DepTime, ArrTime)
> print(columns4)
# A tibble: 227,496 x 4
    Year Month DepTime ArrTime
   <int> <int>   <int>   <int>
 1  2011     1    1400    1500
 2  2011     1    1401    1501
 3  2011     1    1352    1502
 4  2011     1    1403    1513
 5  2011     1    1405    1507
 6  2011     1    1359    1503
 7  2011     1    1359    1509
 8  2011     1    1355    1454
 9  2011     1    1443    1554
10  2011     1    1443    1553
# ... with 227,486 more rows


# 문> hflights데이터셋으로부터 출발지연시간과 도착지연시간과의 차이를 계산한 컬럼 추가
> delay_diff <- flights_df %>% mutate(delaydiff = DepDelay - ArrDelay)
> delay_diff_select <- delay_diff %>% select(delaydiff)
> print(delay_diff_select)
# A tibble: 227,496 x 1
   delaydiff
       <int>
 1        10
 2        10
 3         0
 4         0
 5         8
 6         6
 7         0
 8        11
 9        -1
10         0
# ... with 227,486 more rows


# 문> hflights데이터셋으로부터 도착 시간에 대한 평균, 표준편차 계산
> summarise(hflights, delay=mean(AirTime, na.rm=T))
     delay
1 108.1423
> summarise(hflights, arrTimeSd = sd(AirTime, na.rm=T),
            arrTimeVar = var(AirTime, na.rm=T))  # var() : 분산
  arrTimeSd arrTimeVar
1  56.55523   3198.494
```



- exam.csv 데이터

```R
> exam <-read.csv("./data/exam.csv")
> print(head(exam))
  id class math english science
1  1     1   50      98      50
2  2     1   60      97      60
3  3     1   45      86      78
4  4     1   30      98      58
5  5     2   25      80      65
6  6     2   50      89      98
> summary_exam <- exam %>% summarise(mean_math=mean(math), 
                                     sum_math=sum(math),
                                     median_math =median(math),
                                     sd_math=sd(math),
                                     min_math=min(math),
                                     max_math=max(math),
                                     n=n()) 

> print(summary_exam)
  mean_math sum_math median_math  sd_math min_math max_math  n
1     57.45     1149          54 20.29901       20       90 20
```



- Grouping

```R
> group_summary  <- exam %>% group_by(class) %>% summarise(mean_math=mean(math), 
                                                           sum_math=sum(math),
                                                           median_math =median(math),
                                                           sd_math=sd(math),
                                                           min_math=min(math),
                                                           max_math=max(math),
                                                           n=n())
> print(group_summary)
# A tibble: 5 x 8
  class mean_math sum_math median_math sd_math
  <int>     <dbl>    <int>       <dbl>   <dbl>
1     1      46.2      185        47.5   12.5 
2     2      61.2      245        65     29.5 
3     3      45        180        47.5   18.7 
4     4      56.8      227        53     13.3 
5     5      78        312        79      9.90
# ... with 3 more variables: min_math <int>,
#   max_math <int>, n <int>
```



- ggplot2 패키지의 데이터

```R
> install.packages("ggplot2")
> library(ggplot2)


#자동차 배기량에 따라 고속도록 연비 ...데이터 셋
> mpg <- as.data.frame(ggplot2::mpg)
> print(head(mpg))
  manufacturer model displ year cyl      trans drv cty hwy fl   class
1         audi    a4   1.8 1999   4   auto(l5)   f  18  29  p compact
2         audi    a4   1.8 1999   4 manual(m5)   f  21  29  p compact
3         audi    a4   2.0 2008   4 manual(m6)   f  20  31  p compact
4         audi    a4   2.0 2008   4   auto(av)   f  21  30  p compact
5         audi    a4   2.8 1999   6   auto(l5)   f  16  26  p compact
6         audi    a4   2.8 1999   6 manual(m5)   f  18  26  p compact

> str(mpg)
'data.frame':	234 obs. of  11 variables:
 $ manufacturer: chr  "audi" "audi" "audi" "audi" ...
 $ model       : chr  "a4" "a4" "a4" "a4" ...
 $ displ       : num  1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ...
 $ year        : int  1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ...
 $ cyl         : int  4 4 4 4 6 6 6 4 4 4 ...
 $ trans       : chr  "auto(l5)" "manual(m5)" "manual(m6)" "auto(av)" ...
 $ drv         : chr  "f" "f" "f" "f" ...
 $ cty         : int  18 21 20 21 16 18 18 18 16 20 ...
 $ hwy         : int  29 29 31 30 26 26 27 26 25 28 ...
 $ fl          : chr  "p" "p" "p" "p" ...
 $ class       : chr  "compact" "compact" "compact" "compact" ...


# Quiz> 회사별로 분리, suv 추출, 통합 연비(도시연비+고속도로 연비) 변수 생성, 통합 연비 평균 산출, 내림차순 정렬, 1~5위까지 출력
> cars <- mpg %>% group_by(manufacturer) %>% filter(class=="suv") %>% mutate(yeonbi=cty+hwy) %>% summarise(avg_yeonbi=mean(yeonbi)) %>% arrange(desc(avg_yeonbi)) %>% head(5)
> print(cars)
# A tibble: 5 x 2
  manufacturer avg_yeonbi
  <chr>             <dbl>
1 subaru             43.8
2 toyota             32.6
3 nissan             31.8
4 mercury            31.2
5 jeep               31.1

# 어떤 회사에서 "compact"(경차) 차종을 가장 많이 생산하는지 알아보려고 한다. 각 회사별로 "compact" 차종을 내림차순으로 정렬해 출력하라
> cars2 <- mpg %>% filter(class=="compact") %>% group_by(manufacturer) %>% mutate(count=n()) %>% arrange(desc(count))
> print(cars2)
# A tibble: 47 x 12
# Groups:   manufacturer [5]
   manufacturer model displ  year   cyl trans drv  
   <chr>        <chr> <dbl> <int> <int> <chr> <chr>
 1 audi         a4      1.8  1999     4 auto~ f    
 2 audi         a4      1.8  1999     4 manu~ f    
 3 audi         a4      2    2008     4 manu~ f    
 4 audi         a4      2    2008     4 auto~ f    
 5 audi         a4      2.8  1999     6 auto~ f    
 6 audi         a4      2.8  1999     6 manu~ f    
 7 audi         a4      3.1  2008     6 auto~ f    
 8 audi         a4 q~   1.8  1999     4 manu~ 4    
 9 audi         a4 q~   1.8  1999     4 auto~ 4    
10 audi         a4 q~   2    2008     4 manu~ 4    
# ... with 37 more rows, and 5 more variables:
#   cty <int>, hwy <int>, fl <chr>, class <chr>,
#   count <int>
```



### 3. RJDBC 패키지

> - OracleDB로부터 R실행환경(메모리)로 데이터 가져오기
> - RJDBC::JDBC("driver이름", "driver가 존재하는 클래스경로", "DB에서 문자열 처리")
>   - dbConnect(driver객체, DB_Url, user, password)
>   - dbGetQuery(connection객체,  select sql문장)

```R
> install.packages("RJDBC")
> library(RJDBC)
> library(rJava)

> drv <- JDBC("oracle.jdbc.OracleDriver",
              classPath="C:/app/student/product/11.2.0/dbhome_1/jdbc/lib/ojdbc6.jar",
              identifier.quote="'")
> con <- dbConnect(drv, "jdbc:oracle:thin:@localhost:1521:orcl", "hr", "oracle")
> rs <- dbGetQuery(con, "select tname from tab")
> rs
                            TNAME
1                             BBS
2                     BBS_COMMENT
3                        BBS_FILE
4  BIN$0pNDo42jRL2asjhacPySXg==$0
5  BIN$ucIlPTx/R7uU01RTL6/OmQ==$0
6  BIN$z19LlIYvToK/3gHGoESXjg==$0
7                       COUNTRIES
8                     DEPARTMENTS
9                       EMAILLIST
10                      EMPLOYEES
11               EMP_DETAILS_VIEW
12                           JOBS
13                    JOB_HISTORY
14                      LOCATIONS
15                        PRODUCT
16                       PRODUCTS
17                        REGIONS
18                       USERINFO
```





### 4. igraph 패키지

> 관계도를 시각화

```R
> install.packages("igraph")
> library(igraph)

> g1 <- graph(c(1, 2, 2, 3, 2, 4, 1, 4, 5, 5, 3, 6))
> print(g1)
IGRAPH 2d77fbd D--- 6 6 -- 
+ edges from 2d77fbd:
[1] 1->2 2->3 2->4 1->4 5->5 3->6

> str(g1)
List of 10
 $ :List of 1
  ..$ : 'igraph.vs' int [1:2] 2 4
  .. ..- attr(*, "env")=<weakref> 
  .. ..- attr(*, "graph")= chr "2d77fbd6-d38d-11e9-9e92-213bf28bd404"
 $ :List of 1
  ..$ : 'igraph.vs' int [1:2] 3 4
  .. ..- attr(*, "env")=<weakref> 
  .. ..- attr(*, "graph")= chr "2d77fbd6-d38d-11e9-9e92-213bf28bd404"
 $ :List of 1
  ..$ : 'igraph.vs' int 6
  .. ..- attr(*, "env")=<weakref> 
  .. ..- attr(*, "graph")= chr "2d77fbd6-d38d-11e9-9e92-213bf28bd404"
 $ :List of 1
  ..$ : 'igraph.vs' int(0) 
  .. ..- attr(*, "env")=<weakref> 
  .. ..- attr(*, "graph")= chr "2d77fbd6-d38d-11e9-9e92-213bf28bd404"
 $ :List of 1
  ..$ : 'igraph.vs' int 5
  .. ..- attr(*, "env")=<weakref> 
  .. ..- attr(*, "graph")= chr "2d77fbd6-d38d-11e9-9e92-213bf28bd404"
 $ :List of 1
  ..$ : 'igraph.vs' int(0) 
  .. ..- attr(*, "env")=<weakref> 
  .. ..- attr(*, "graph")= chr "2d77fbd6-d38d-11e9-9e92-213bf28bd404"

> plot(g1)
```

![8](190910%20R.assets/8.JPG)



```R
> name <- c("세종대왕", "일지매 부장", "김유신 과장", "손흥민 대리",
           "이순신 부장", "유관순 차장", "신사임당 대리", "강감찬 부장",
           "광개토 과장", "정몽주 대리")
> pemp <- c("세종대왕", "세종대왕", "일지매 부장", "김유신 과장", 
            "세종대왕",  "이순신 부장", "유관순 차장",  "세종대왕", 
            "강감찬 부장", "광개토 과장")

> emp <- data.frame(이름=name, 상사이름=pemp)
> print(emp)
            이름    상사이름
1       세종대왕    세종대왕
2    일지매 부장    세종대왕
3    김유신 과장 일지매 부장
4    손흥민 대리 김유신 과장
5    이순신 부장    세종대왕
6    유관순 차장 이순신 부장
7  신사임당 대리 유관순 차장
8    강감찬 부장    세종대왕
9    광개토 과장 강감찬 부장
10   정몽주 대리 광개토 과장

> g <- graph.data.frame(emp, direct=T)
> plot(g, layout=layout.frunchterman.reingold,
       vertex.size=8, edge.arrow.size=0.5)
```

![9](190910%20R.assets/9.JPG)



### 5. reshape 패키지

> 데이터 셋의 구성이 구분변수(identifier variable)에 의해서 특정 변수가 분류된 경우, 데이터 셋의 모양을 변경하는 패키지
>
> - 구분변수(identifier variable) : 데이터 셋에 1개 이상으로 분류되는 집단변수
> - 측정변수(measured variable): 구분변수에 의해서 구분되는 변수



#### 1) rename()

```R
> install.packages("reshape")
> library(reshape)

> result <- read.csv("./data/reshape.csv", header=FALSE)
> head(result)
   V1  V2  V3  V4
1 5.1 1.4 0.2 3.5
2 4.9 1.4 0.2 3.0
3 4.7 1.3 0.2 3.2
4 4.6 1.5 0.2 3.1
5 5.0 1.4 0.2 3.6
6 5.4 1.7 0.4 3.9

#데이터 파일을 가져오는 경우 컬럼명이 없으면 기본적으로 'V1, V2, V3...' 형식으로 기본 컬럼명이 적용되므로 데이터 셋의 컬럼명을 변경하려면 rename()함수를 사용한다.
> result <- rename(result, c(V1="total", V2="num1", V3="num2", V4="num3"))
> head(result)
  total num1 num2 num3
1   5.1  1.4  0.2  3.5
2   4.9  1.4  0.2  3.0
3   4.7  1.3  0.2  3.2
4   4.6  1.5  0.2  3.1
5   5.0  1.4  0.2  3.6
6   5.4  1.7  0.4  3.9
```



#### 2) reshape(), melt()

> 구분변수를 기준으로 측정변수를 분류해 새로운 컬럼을 생성

- reshape(data.frame, varying="반복되는 측정 색인",

  ​				v.names="반복되는 측정값", timevar="반복되는 측정 시간",

  ​				idvar="1개 이상의 값으로 분류되는 변수, direct="wide/long)

  - wide : 기준변수와 관련 변수가 1대n 관계로 관측치가 구성 
  - long : 기준변수와 관련 변수가 1대1 관계로 관측치가 구성

```R
> data('Indometh')
> str(Indometh) # 생체내에서 약물의 흡수, 분포, 비축, 대사, 배설의 과정
Classes ‘nfnGroupedData’, ‘nfGroupedData’, ‘groupedData’ and 'data.frame':	66 obs. of  3 variables:
 $ Subject: Ord.factor w/ 6 levels "1"<"4"<"2"<"5"<..: 1 1 1 1 1 1 1 1 1 1 ...
 $ time   : num  0.25 0.5 0.75 1 1.25 2 3 4 5 6 ...
 $ conc   : num  1.5 0.94 0.78 0.48 0.37 0.19 0.12 0.11 0.08 0.07 ...
 - attr(*, "formula")=Class 'formula'  language conc ~ time | Subject
  .. ..- attr(*, ".Environment")=<environment: R_EmptyEnv> 
 - attr(*, "labels")=List of 2
  ..$ x: chr "Time since drug administration"
  ..$ y: chr "Indomethacin concentration"
 - attr(*, "units")=List of 2
  ..$ x: chr "(hr)"
  ..$ y: chr "(mcg/ml)"
> # Subject(실험대상), time(약물 투여시간: hour단위), conc(농도: ml/mcg 단위)
> Indometh  # long 형식
Grouped Data: conc ~ time | Subject
   Subject time conc
1        1 0.25 1.50
2        1 0.50 0.94
3        1 0.75 0.78
4        1 1.00 0.48
5        1 1.25 0.37
6        1 2.00 0.19
.
.
.
60       6 1.25 0.64
61       6 2.00 0.42
62       6 3.00 0.24
63       6 4.00 0.17
64       6 5.00 0.13
65       6 6.00 0.10
66       6 8.00 0.09

# 기준변수 : timevar="time", idvar="Subject"
# 관측변수 : v.names="conc"
# 실험대상 1을 기준으로 약물투여시간 0.25에서 8까지의 ...농도를
> wide <- reshape(Indometh, v.names="conc", timevar="time", idvar="Subject", direction="wide")
> wide
   Subject conc.0.25 conc.0.5
1        1      1.50     0.94
12       2      2.03     1.63
23       3      2.72     1.49
34       4      1.85     1.39
45       5      2.05     1.04
56       6      2.31     1.44
   conc.0.75 conc.1 conc.1.25 conc.2
1       0.78   0.48      0.37   0.19
12      0.71   0.70      0.64   0.36
23      1.16   0.80      0.80   0.39
34      1.02   0.89      0.59   0.40
45      0.81   0.39      0.30   0.23
56      1.03   0.84      0.64   0.42
   conc.3 conc.4 conc.5 conc.6 conc.8
1    0.12   0.11   0.08   0.07   0.05
12   0.32   0.20   0.25   0.12   0.08
23   0.22   0.12   0.11   0.08   0.08
34   0.16   0.11   0.10   0.07   0.07
45   0.13   0.11   0.08   0.10   0.06
56   0.24   0.17   0.13   0.10   0.09
> wide
   Subject conc.0.25 conc.0.5 conc.0.75 conc.1 conc.1.25 conc.2
1        1      1.50     0.94      0.78   0.48      0.37   0.19
12       2      2.03     1.63      0.71   0.70      0.64   0.36
23       3      2.72     1.49      1.16   0.80      0.80   0.39
34       4      1.85     1.39      1.02   0.89      0.59   0.40
45       5      2.05     1.04      0.81   0.39      0.30   0.23
56       6      2.31     1.44      1.03   0.84      0.64   0.42
   conc.3 conc.4 conc.5 conc.6 conc.8
1    0.12   0.11   0.08   0.07   0.05
12   0.32   0.20   0.25   0.12   0.08
23   0.22   0.12   0.11   0.08   0.08
34   0.16   0.11   0.10   0.07   0.07
45   0.13   0.11   0.08   0.10   0.06
56   0.24   0.17   0.13   0.10   0.09
> wide
   Subject conc.0.25 conc.0.5 conc.0.75 conc.1 conc.1.25 conc.2 conc.3
1        1      1.50     0.94      0.78   0.48      0.37   0.19   0.12
12       2      2.03     1.63      0.71   0.70      0.64   0.36   0.32
23       3      2.72     1.49      1.16   0.80      0.80   0.39   0.22
34       4      1.85     1.39      1.02   0.89      0.59   0.40   0.16
45       5      2.05     1.04      0.81   0.39      0.30   0.23   0.13
56       6      2.31     1.44      1.03   0.84      0.64   0.42   0.24
   conc.4 conc.5 conc.6 conc.8
1    0.11   0.08   0.07   0.05
12   0.20   0.25   0.12   0.08
23   0.12   0.11   0.08   0.08
34   0.11   0.10   0.07   0.07
45   0.11   0.08   0.10   0.06
56   0.17   0.13   0.10   0.09


# 다시 wide를 long으로
> reshape(wide, direction="long")
       Subject time conc
1.0.25       1 0.25 1.50
2.0.25       2 0.25 2.03
3.0.25       3 0.25 2.72
4.0.25       4 0.25 1.85
5.0.25       5 0.25 2.05
6.0.25       6 0.25 2.31
.
.
.
1.8          1 8.00 0.05
2.8          2 8.00 0.08
3.8          3 8.00 0.08
4.8          4 8.00 0.07
5.8          5 8.00 0.06
6.8          6 8.00 0.09


# varying="반복되는 측정 색인" 사용
> long <- reshape(wide, idvar="Subject", varying=2:12,
                  v.names="conc",  direction="long" )
> str(long)
'data.frame':	66 obs. of  3 variables:
 $ Subject: Ord.factor w/ 6 levels "1"<"4"<"2"<"5"<..: 1 3 6 2 4 5 1 3 6 2 ...
 $ time   : int  1 1 1 1 1 1 2 2 2 2 ...
 $ conc   : num  1.5 2.03 2.72 1.85 2.05 2.31 0.94 1.63 1.49 1.39 ...
 - attr(*, "reshapeLong")=List of 4
  ..$ varying:List of 1
  .. ..$ conc: chr  "conc.0.25" "conc.0.5" "conc.0.75" "conc.1" ...
  .. ..- attr(*, "v.names")= chr "conc"
  .. ..- attr(*, "times")= int  1 2 3 4 5 6 7 8 9 10 ...
  ..$ v.names: chr "conc"
  ..$ idvar  : chr "Subject"
  ..$ timevar: chr "time"
```



- melt(data, id="기준변수", measured="측정변수")
  - melt는 구분변수를 기준으로 측정변수를 긴 형식에서 넓은 형식으로 변경

```R
> smiths
     subject time age weight height
1 John Smith    1  33     90   1.87
2 Mary Smith    1  NA     NA   1.54

# 기준변수 ("subject", "time")를 이용해 측정변수 분류
> melt(smiths, id=c("subject", "time"))
     subject time variable value
1 John Smith    1      age 33.00
2 Mary Smith    1      age    NA
3 John Smith    1   weight 90.00
4 Mary Smith    1   weight    NA
5 John Smith    1   height  1.87
6 Mary Smith    1   height  1.54

> melt(smiths, id=c("subject", "time"), measured=c("age"))
     subject time variable value
1 John Smith    1      age 33.00
2 Mary Smith    1      age    NA
3 John Smith    1   weight 90.00
4 Mary Smith    1   weight    NA
5 John Smith    1   height  1.87
6 Mary Smith    1   height  1.54

> melt(smiths, id=c("subject", "time"), measured=c("age", "weight", "height"))
     subject time variable value
1 John Smith    1      age 33.00
2 Mary Smith    1      age    NA
3 John Smith    1   weight 90.00
4 Mary Smith    1   weight    NA
5 John Smith    1   height  1.87
6 Mary Smith    1   height  1.54

> melt(smiths, id=c(1:2), na.rm=T)
     subject time variable value
1 John Smith    1      age 33.00
2 John Smith    1   weight 90.00
3 John Smith    1   height  1.87
4 Mary Smith    1   height  1.54
```



#### 3) cast()

> 측정변수에 집합함수를 적용

- cast(data, formula식, ~측정변수, 집합함수)

```R
> smithsm <- melt(smiths, id=c(1:2))
> smithsm
     subject time variable value
1 John Smith    1      age 33.00
2 Mary Smith    1      age    NA
3 John Smith    1   weight 90.00
4 Mary Smith    1   weight    NA
5 John Smith    1   height  1.87
6 Mary Smith    1   height  1.54

# subject와 time 변수를 이용해 측정변수(age, weight, height)를 분류
> cast(smithsm, subject = ~variable)
     subject time age weight height
1 John Smith    1  33     90   1.87
2 Mary Smith    1  NA     NA   1.54
```



#### 4) 실습

```R
# Indometh 데이터셋으로부터 subject와 time을 구분변수로 long 형식으로 변환
> melt(Indometh, id=c("Subject", "time"))
   Subject time variable value
1        1 0.25     conc  1.50
2        1 0.50     conc  0.94
3        1 0.75     conc  0.78
4        1 1.00     conc  0.48
.
.
.
63       6 4.00     conc  0.17
64       6 5.00     conc  0.13
65       6 6.00     conc  0.10
66       6 8.00     conc  0.09


# subject를 구분변수로 측정변수 농도의 합계 통계량을 계산하라


# subject구분변수로 특정변수 농도의 평균, 최소값~최대값 범위를 계산


```





### 6. 게임회사 데이터 실제로 다뤄보기

```R
# 데이터 불러오기
dau <- read.csv("./data/dau.csv")
dpu <- read.csv("./data/dpu.csv")
install <- read.csv("./data/install.csv")

# JOIN
dau_install <- join(dau, install, by="user_id", type="full")
join_all <- join(dau_install, dpu, by=c("log_date", "user_id"), type="full")

# NA값을 전부 0으로 처리
is.na(join_all)
join_all$payment[is.na(join_all$payment)] <- 0
is.na(join_all)

head(join_all)

# 월 컬럼 추가
month_add <- join_all %>% mutate(month=substr(log_date, 1, 7))
head(month_add)

# 월별 그룹핑 & 과금액 집계
grouping <- month_add %>% group_by(month) 
summarise(grouping, sum_payment=sum(payment))

# 신규 유저, 기존 유저 구분 칼럼 추가
new_old <- month_add %>% mutate(user_type=ifelse(as.Date(log_date)>as.Date(install_date), 'old', 'new'))
head(new_old)

# 신규 유저, 기존 유저 월별 소비액
new_old_payment <- ddply(new_old, .(user_type), summarise, sum6=)
na.omit(new_old_payment)

# 히스토그램 그리기
```



```R
# 선생님 풀이
 
# CSV 파일을 읽어들이기
dau <- read.csv("./data/dau.csv", header = T, stringsAsFactors = F)
head(dau)
dpu <- read.csv("./data/dpu.csv", header = T, stringsAsFactors = F)
head(dpu)
install <- read.csv("./data/install.csv", header = T, stringsAsFactors= F)
head(install)


# DAU 데이터에 Install 데이터를 결합시키기 (merge함수)
# 기준변수 ("user_id", "app_name")
dau.install <- merge(dau, install, by = c("user_id", "app_name"))
head(dau.install)

# 1차결합된 데이터에 DPU 데이터를 결합시키기 (merge함수)
# 기준변수 (("log_date", "app_name", "user_id") 
dau.install.payment <- merge(dau.install, dpu, 
                       by = c("log_date","app_name", "user_id"), 
                       all.x = T)
head(dau.install.payment, 20)
head(na.omit(dau.install.payment))

# 비과금 유저의 과금액에 0을 넣기 ( data[row,col]<-0)
#데이터객체[is.na(데이터객체$컬럼명)] <- 0
dau.install.payment$payment[is.na(dau.install.payment$payment)] <- 0
head(dau.install.payment, 20)

# 월 항목 추가   (data.frame객체$새컬럼변수 <- 추가될 데이터, mutate, cbind 등 이용)
dau.install.payment$log_month <-substr(dau.install.payment$log_date, 1, 7)
dau.install.payment$install_month <- substr(dau.install.payment$install_date, 1, 7)
head(dau.install.payment, 20)


# 추가된 월 항목으로 그룹핑후 과금액 집계 (ddply, aggregate, dplyr::group_by등 이용)
mau.payment <- ddply(dau.install.payment,
                     .(log_month, user_id, install_month), # 그룹화
                     summarize, # 집계 명령
                     payment = sum(payment) # payment 합계
                     )

head(mau.payment, 10)


# 신규 유저인지 기존 유저인지 구분하는 항목의 새 컬럼변수 추가
mau.payment$user.type <-  ifelse(mau.payment$install_month == mau.payment$log_month, "new", "old")

# 그래프로 데이터 시각화 
library("ggplot2")
ggplot(mau.payment.summary, aes(x = log_month, 
                             y = total.payment,
                             fill = user.type)) + 
       geom_bar(stat="identity") 

```

